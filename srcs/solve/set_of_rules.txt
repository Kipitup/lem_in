Each room will have a variable 'distance'
	distance = how many steps are between start and the room

Each link will have a variable 'available'
	available = TRUE 
				FALSE

We cycle through the list the natural way, first in first out.

Moreover, when bfs finish on END:
	if many paths have the same distance, from right to left, we add one by one valid
	(only unused nodes and no double crossing links) paths to our solution.

Every exploration will be made on a copy of the graph, (dup of the adjacency list).

Every possible BFS solution will be store in a darray. Each bucket will contain a
a linked list with all the paths. Each path will has his own linked list with all
the room it's going through.

BFS exploration phase:
	- Every time you visit a room:
		- update the link status.
		- update distance.
	- A room is considered VISITED only when all its links have be checked.
	- You can only visit a room if the link to the room is available in your direction.
	- If a room's distance has been set, do not change the distance.
	- The BFS will stop if:
		- every room has been visited
		- the room END has been reached

BFS go back and find the path:
	- As said earlier, first in first out.
	- Every time you go back to a room, add this room to the linked list.

BFS path found:
	- If a link (or more) is equal 3 (BOTH direction are used):
		- Save and add only valid paths to the struct.
		- Reset the all of the graph (distance, link, previously deleted link).
		- Delete the used link. (all of them) 
		- Restart the BFS.
	- Else:
		- Restart the BFS.

After all BFS possibily has been explored:
	- Do some simulation on every possible BFS you found. Something like:
		- portion = nb_of_ant / nb_path; (need to check if nb_ant % nb_path == 0)
		- total = path_1->distance * portion + .. + path_n->distance  * portion;
	- Take the fatest.


Potential(s) problem(s):
	-  How to dispatch the ant is wrong => it a flow, so fill every path until they
	are full
